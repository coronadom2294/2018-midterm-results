<!-- DOING: Standarizing on "office" -->
<div class="office { countyMap ? 'row' : 'no-map'} { condensed ? 'condensed' : ''} cf type-{ voteType } { partisan ? 'partisan' : 'nonpartisan' }" id="{ id }">
  <div class="office-table { countyMap ? 'col col-100 col-md-50' : ''}">
    <div class="office-details">
      <h4 class="font-benton-sans">{ supplementedTitle }</h4>
      <!-- <p class="timestamp">Last updated: { updatedDate ? makeDate(updatedDate) : '-' }</p> -->
      {#if description}
        <p class="office-chat">{@html description }</p>
      {/if}
    </div>

    {#if contests}
      {#each contests as contest}
        {#if !parties || (parties && contest.party && ~parties.indexOf(contest.party.id))}
          <Contest id="{ contest.id }"
            {...contest}
            embedded="{ true }"
            loaded="{ loaded }"
            supplement="{ supplement }"
            countyMap="{ countyMap }" />
        {/if}
      {/each}
    {/if}
  </div>


  {#if countyMap}
  <!-- {#if countyMap && subResults && subResults.county} -->
    <div class="office-map { countyMap ? 'col col-100 col-md-50' : ''}">
      <img src="http://www.placepuppy.net/500/400" alt="map placeholder" />
    </div>

    <!-- <CountyMap subResults="{ subResults.county }"
      candidates="{ candidates }"
      keyedResults="{ keyedResults }" /> -->
  {/if}
</div>


<script>
  /* global moment */
  // Dependencies and components
  import Contest from "./_content-contest.svelte.html";
  import { isArray } from "lodash";
  import Civix from "../app/shared/civix.js";

  // Svelte logic
  export default {
    components: {
      Contest
    },

    oncreate() {
      if (!this.get().embedded) {
        this.civix = new Civix(`contests/by-office/${this.get().id}`);
        this.civix.on("update", office => {
          this.set(office);
          this.set({ loaded: true });
        });
        this.civix.poll();
      }
    },

    ondestroy() {
      if (this.civix) {
        this.civix.cancel();
      }
    },

    helpers: {
      makeDate: (date, format) => {
        let m = moment(date);
        let now = moment();
        if (!m || !m.isValid()) {
          return "";
        }

        return m.isSame(now, "date")
          ? m.format("h:mm a")
          : m.format("MMM D h:mm a");
      }
    },

    computed: {
      supplementedTitle: ({
        id,
        supplement,
        title,
        defaultTitle,
        shortTitle,
        embedded
      }) => {
        return supplement && id && supplement[id] && supplement[id].title
          ? supplement[id].title
          : defaultTitle
            ? defaultTitle
            : embedded && shortTitle
              ? shortTitle
              : title || "-";
      },
      description: ({ id, supplement }) => {
        return supplement && id && supplement[id] && supplement[id].description
          ? supplement[id].description
          : undefined;
      },
      updatedDate: ({ contests }) => {
        if (!contests) {
          return;
        }
        // TODO: Get newest/oldest date
        return (
          contests[0].results[0].apUpdated || contests[0].results[0].last_updated
        );
      }
    },

    methods: {},

    data: () => {
      return {};
    }
  };
</script>
